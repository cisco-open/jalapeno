package {{packageName}}

import (
	"net/http"
	"fmt"
	"github.com/gorilla/mux"
)
// Middleware wraps handlers
type Middleware func(http.Handler) http.Handler

type Router struct {
	*mux.Router
}


// Route holds route information. Handler/Middleware are net/http package compatable
// handlers.
type Route struct {
	Name          string
	Method        string
	Pattern       string
	Handler       http.HandlerFunc
	Middleware    []Middleware
}

type Routes []Route

func newRouter() *Router {
	return &Router{mux.NewRouter().StrictSlash(true)}
}

func (r *Router) InitRoutes(s *Server) {
	var routes = Routes{
	{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}
		Route{
			Name: "{{operationId}}",
			Method: "{{httpMethod}}",
			Pattern: "{{{basePathWithoutHost}}}{{{path}}}",
			Handler: s.{{operationId}},
			Middleware: []Middleware{},
		},
	{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
	}
	for _, route := range routes {
		r.AddRoute(route)
	}

}

// AddRoute adds routes and wraps the handlers in the provided middleware.
func (r *Router) AddRoute(route Route) {
	entry := r.
		Methods(route.Method).
		Path(route.Pattern).
		Name(route.Name)

	if route.Handler != nil {
		handler := route.Handler
		for _, mw := range route.Middleware {
			handler = mw(handler).(http.HandlerFunc)
		}
		entry.Handler(handler)
	}
}

// MW is a convenience function to construct Middleware arrays (shortcut for Route field construction.)
func MW(mw ...Middleware) []Middleware {
	var mwArray []Middleware
	for _, m := range mw {
		mwArray = append(mwArray, m)
	}
	return mwArray
}
